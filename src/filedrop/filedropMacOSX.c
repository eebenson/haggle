/* Copyright 2008 Uppsala University
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); 
 * you may not use this file except in compliance with the License. 
 * You may obtain a copy of the License at 
 *     
 *     http://www.apache.org/licenses/LICENSE-2.0 
 *
 * Unless required by applicable law or agreed to in writing, software 
 * distributed under the License is distributed on an "AS IS" BASIS, 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
 * See the License for the specific language governing permissions and 
 * limitations under the License.
 */ 


// adding files in a specified path to haggle

// usage: haggleDrop <path> 
// if no path given, HAGGLE_FOLDER_PATH_DEFAULT is used

// Note: supports only files with Mac OS X metadata of type 
// - kMDItemKeywords      (can be generated by adding keywords to pictures in e.g., iPhoto)
// Other types can be added in print attributes. 

#include <stdio.h>
#include <dirent.h>
#include <string.h>
#include <search.h>
#include <signal.h>

#include <CoreFoundation/CoreFoundation.h>
#include <CoreFoundation/CFString.h>
#include <CoreServices/CoreServices.h>

#include <libhaggle/haggle.h>


static haggle_handle_t hh;

#define HAGGLE_FOLDER_PATH_DEFAULT "/Users/chrohner/Desktop/HaggleDrop"

static void cleanup(int signal)
{
	switch(signal) {
		case SIGKILL:
		case SIGHUP:
		case SIGINT:
		case SIGTERM:
			haggle_handle_free(hh);
			exit(EXIT_SUCCESS);
			break;
		default:
			break;
	}
}

void printAttributes(char* path) 
{
	CFStringRef inPath = CFStringCreateWithCString(NULL, path, kCFStringEncodingMacRoman);
	
	MDItemRef item = (MDItemRef)MDItemCreate(NULL, inPath);
	if (item != NULL) {
		/*
		 CFArrayRef attributeNames = MDItemCopyAttributeNames(item);
		 CFDictionaryRef attributes = MDItemCopyAttributes(item, attributeNames);
		 */
		
		CFDictionaryRef attributes = MDItemCopyAttributeList(item, kMDItemKeywords, NULL);
		CFStringRef *keys = (CFStringRef*) malloc(CFDictionaryGetCount(attributes) * sizeof(CFStringRef));
		CFArrayRef *values = (CFArrayRef*) malloc(CFDictionaryGetCount(attributes) * sizeof(CFArrayRef));
		
		if (CFDictionaryGetCount(attributes) > 0) {
			
			haggle_dobj_t *dobj;
			
			dobj = haggle_dataobject_new_from_file(path);
			
			CFDictionaryGetKeysAndValues(attributes, (const void**)keys, (const void**)values);
			
			int i;
			for (i=0; i<CFDictionaryGetCount(attributes); i++) {
				char cKey[100];
				char cValue[100];
				CFStringGetCString((CFStringRef)keys[i], cKey, 100, kCFStringEncodingISOLatin1);
				
				CFArrayRef keywords = (CFArrayRef)values[i];
				int k;
				for (k=0; k<CFArrayGetCount(keywords); k++) {
					CFStringGetCString((CFStringRef)CFArrayGetValueAtIndex(keywords,k), cValue, 100, kCFStringEncodingISOLatin1);
					// haggle_dataobject_add_attribute(dobj, cKey, cValue);
					// for demo purposes, add Picture=... attribute
					haggle_dataobject_add_attribute(dobj, "Picture", cValue);
					printf("  attr: %s=%s\n", "Picture", cValue);
				}
			}

			haggle_dataobject_add_hash(dobj);
			haggle_ipc_publish_dataobject(hh, dobj);
			haggle_dataobject_free(dobj);
		}
	}
}


static int cmp(const void *a, const void *b) {
	if (*(int *)a < *(int *)b) return -1;
	if (*(int *)a > *(int *)b) return 1;
	return 0;
}

void checkChange(char* path) 
{
	static void *treeCurrent = NULL;
	static void *treeCache = NULL;
	static struct dirent **current;
	static struct dirent **cache;
	static int numCache = 0;
	static int numCurrent = 0;
	int i;
	
	numCurrent = scandir(path, &current, NULL, NULL);
	
	// printf("-- checkChange %s (%d:%d) \n", path, numCurrent, numCache);
	
	for (i=0; i<numCurrent; i++) {
		void *node = tfind(&current[i]->d_ino, &treeCache, &cmp);
		if (!node && current[i]->d_type == DT_REG) {
			char buf[2048];
			printf("New File: %s\n", current[i]->d_name);
			sprintf(buf, "%s%s", path, current[i]->d_name);
			printAttributes(buf);
		}
		tsearch(&current[i]->d_ino, &treeCurrent, &cmp);
	}
	
	for (i=0; i<numCache; i++) {
		void *node = tfind(&cache[i]->d_ino, &treeCurrent, &cmp);
		if (!node) {
			printf("Removed File: %s\n", cache[i]->d_name);
		}
		tdelete(&cache[i]->d_ino, &treeCache, &cmp);
	}
	
	
	// free cache:
	for (i=0; i<numCache; i++) {
		free(cache[i]);
	}
	free (cache);
	
	cache = current;
	numCache = numCurrent;
	
	treeCache = treeCurrent;
	treeCurrent = NULL;
}


static void onFSEvents(ConstFSEventStreamRef streamRef, void *clientCallBackInfo, size_t numEvents, void *eventPaths, const FSEventStreamEventFlags eventFlags[], const FSEventStreamEventId eventIds[]) {
	char **paths = eventPaths;
	int i;
	for (i = 0; i < numEvents; i++) {
		checkChange(paths[i]);
	}
}


int onShutdown(haggle_event_t *e, void *arg)
{
	printf("Haggle was shutdown, exiting\n");
	haggle_handle_free(hh);
	exit(EXIT_SUCCESS);
	
	return 0;
}
		
int main(int argc, const char *argv[])
{
	/* Make sure we cleanup at exit... */
	struct sigaction sigact;
	atexit((void *) &cleanup);
	
	sigact.sa_handler = &cleanup;
	sigaction(SIGHUP, &sigact, NULL);
	sigaction(SIGINT, &sigact, NULL);
	sigaction(SIGKILL, &sigact, NULL);
	
	FSEventStreamContext *_context;
	FSEventStreamRef _stream;
	CFStringRef cfPath;
	const char *path;
	
	if (argc > 1) {
		path = argv[1];
	} else {
		path = HAGGLE_FOLDER_PATH_DEFAULT;
	}
	
	if (haggle_handle_get("Filedrop Mac OS X", &hh) != HAGGLE_NO_ERROR) {
		fprintf(stderr, "Could not get Haggle handle\n");
		return -1;
	}
	
	haggle_ipc_register_event_interest(hh, LIBHAGGLE_EVENT_SHUTDOWN, onShutdown);
	
	haggle_event_loop_run_async(hh);
	
		
	cfPath = CFStringCreateWithCString(kCFAllocatorDefault, path, kCFStringEncodingUTF8);
	
	printf("haggleDrop: drop files into %s\n\n", path);
	
	CFArrayRef pathsToWatch = CFArrayCreate(NULL, (const void **)&cfPath, 1, NULL);
	
	CFRelease(cfPath);
	
	/* Use context only to simply pass the array controller */
	_context = (FSEventStreamContext*)malloc(sizeof(FSEventStreamContext));
	_context->version = 0;
	_context->info = NULL;
	_context->retain = NULL;
	_context->release = NULL;
	_context->copyDescription = NULL;
	
	_stream = FSEventStreamCreate(NULL,
				      &onFSEvents,
				      _context,
				      pathsToWatch,
				      kFSEventStreamEventIdSinceNow, /* Or a previous event ID */
				      1.0, /* Latency in seconds */
				      kFSEventStreamCreateFlagNone
				      );
	
	CFRelease(pathsToWatch);
	
	FSEventStreamScheduleWithRunLoop(_stream, CFRunLoopGetCurrent(), kCFRunLoopDefaultMode);    
	FSEventStreamStart(_stream);
	CFRunLoopRun();
	
	haggle_handle_free(hh);
	
	return 0;
}
